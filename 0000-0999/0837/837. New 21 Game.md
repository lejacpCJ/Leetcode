# 837. New 21 Game

## Problem Info

- **Difficulty:** Medium
- **Topics:** Math, Dynamic Programming, Sliding Window, Probability and Statistics
- [Link to the problem](https://leetcode.com/problems/new-21-game/)

## Description

Alice plays the following game, loosely based on the card game "21".

Alice starts with 0 points and draws numbers while she has less than `k` points. During each draw, she gains an integer number of points randomly from the range `[1, maxPts]`, where `maxPts` is an integer. Each draw is independent and the outcomes have equal probabilities.

Alice stops drawing numbers when she gets `k` or more points.

Return the probability that Alice has `n` or fewer points.

Answers within `10^-5` of the actual answer are considered accepted.

## Examples

- **Input:** `n = 10, k = 1, maxPts = 10`  
  **Output:** `1.00000`  
  **Explanation:** Alice gets a single card, then stops.

- **Input:** `n = 6, k = 1, maxPts = 10`  
  **Output:** `0.60000`  
  **Explanation:** Alice gets a single card, then stops. In 6 out of 10 possibilities, she is at or below 6 points.

- **Input:** `n = 21, k = 17, maxPts = 10`  
  **Output:** `0.73278`

## Constraints

- `0 <= k <= n <= 10^4`
- `1 <= maxPts <= 10^4`

---

## Solution

1. **Dynamic Programming:**  
   Let `dp[x]` be the probability that, starting from score `x`, Alice’s final score will be `<= n`
   - For `x >= k` and `x <= n`, Alice stops and wins, so `dp[x] = 1.0`.
   - For `x > n`, `dp[x] = 0.0`.
   - For `x < k`, `dp[x] = (dp[x+1] + dp[x+2] + ... + dp[x+maxPts]) / maxPts`.

2. **Sliding Window Optimization:**  
   To efficiently compute the sum, use a sliding window to maintain the sum of the next `maxPts` probabilities.

**Complexity:**
- **Time:** O(n + maxPts)
- **Space:** O(n + maxPts)

**Python Code:**

```python
def new21Game(n: int, k: int, maxPts: int) -> float:
    # If Alice never draws or can never exceed n, she always wins
    if k == 0 or n >= k + maxPts:
        return 1.0

    # dp[x]: probability of starting from x points and final score be <= n
    dp = [0.0] * (n + maxPts + 1)
    # If Alice stops with x in [k, n], she wins
    for x in range(k, n + 1):
        dp[x] = 1.0

    # Initialize windowSum as the sum of dp[k..n]
    windowSum = n - k + 1  # sum of dp[k..n]
    for x in range(k - 1, -1, -1):
        dp[x] = windowSum / maxPts
        # Update windowSum for the next iteration
        windowSum += dp[x] - dp[x + maxPts]

    return dp[0]
```