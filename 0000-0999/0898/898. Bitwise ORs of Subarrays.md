# 898. Bitwise ORs of Subarrays

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Dynamic Programming, Bit Manipulation
- [Link to the problem](https://leetcode.com/problems/bitwise-ors-of-subarrays/)

## Description

Given an integer array `arr`, return the number of distinct bitwise ORs of all the non-empty subarrays of `arr`.

The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer.

A subarray is a contiguous non-empty sequence of elements within an array.

## Example

Input: `arr = [1,1,2]`  
Output: `3`  
Explanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3.


## Constraints

- `1 <= arr.length <= 5 * 10^4`
- `0 <= arr[i] <= 10^9`

---

## Solution

**Steps:**

The key insight is that for each position `i`, we can maintain all possible OR values ending at position `i`. When we move to position `i+1`, we can extend all previous OR values by ORing them with `arr[i+1]`, plus add `arr[i+1]` itself as a new starting point.

1. **Dynamic Programming Approach**:
   - For each position, maintain a set of all possible OR values ending at that position
   - When processing `arr[i]`, create new OR values by combining `arr[i]` with all OR values from the previous position

2. **Optimization**:
   - The number of distinct OR values ending at any position is at most 32 (since OR can only add new bits, not remove them)
   - Use a set to track all unique OR values seen so far

3. **Implementation**:
   - Use dynamic programming with space optimization
   - Track current possible OR values and update them for each new element

**Complexity:**  

- **Time:** O(n * log(max(arr))), where n is array length. The log factor comes from the fact that there are at most 32 distinct OR values at each position
- **Space:** O(log(max(arr))), for storing the current set of OR values

**Python Code:**

```python
from typing import List

class Solution:
    def subarrayBitwiseORs(self, arr: List[int]) -> int:
        result = set()
        curr = set()
        
        for num in arr:
            # Create new set for current position
            curr = {num | x for x in curr}
            # Add num to the set of current position
            curr.add(num)
            # Add all current OR values to result
            result |= curr
        
        return len(result)
```