# 808. Soup Servings

## Problem Info

- **Difficulty:** Medium
- **Topics:** Math, Dynamic Programming, Probability and Statistics
- [Link to the problem](https://leetcode.com/problems/soup-servings/)

## Description

You have two soups, A and B, each starting with n mL. On every turn, one of the following four serving operations is chosen at random, each with probability 0.25 independent of all previous turns:

- pour 100 mL from type A and 0 mL from type B
- pour 75 mL from type A and 25 mL from type B
- pour 50 mL from type A and 50 mL from type B
- pour 25 mL from type A and 75 mL from type B

Note:
- There is no operation that pours 0 mL from A and 100 mL from B.
- The amounts from A and B are poured simultaneously during the turn.
- If an operation asks you to pour more than you have left of a soup, pour all that remains of that soup.
- The process stops immediately after any turn in which one of the soups is used up.

Return the probability that A is used up before B, plus half the probability that both soups are used up in the same turn. Answers within 10^-5 of the actual answer will be accepted.

## Examples

- Input: `n = 50`
- Output: `0.62500`
- Explanation: If we perform either of the first two serving operations, soup A will become empty first. If we perform the third operation, A and B will become empty at the same time. If we perform the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.


## Constraints

- `0 <= n <= 10^9`

---

## Solution

1. **Key Insight**: Since A is consumed more than B in all operations, for large n, the probability approaches 1.0
2. **Optimization**: For n >= 4800, return 1.0 directly (mathematical observation)
3. **Dynamic Programming**: Use memoization to calculate probabilities for smaller values
4. **State Reduction**: Scale down by 25 to reduce state space (since all operations are multiples of 25)

**Complexity:**

- **Time:** O(k²), where k = n/25 (after scaling, limited by optimization threshold)
- **Space:** O(k²), for memoization table

**Python Code:**

```python
class Solution:
    def soupServings(self, n: int) -> float:
        # For large n, probability approaches 1.0
        if n >= 4800:
            return 1.0
        
        # Scale down by 25 to reduce state space
        # All operations are multiples of 25
        def helper(a, b, memo):
            if (a, b) in memo:
                return memo[(a, b)]
            
            if a <= 0 and b <= 0:
                # Both empty at same time
                return 0.5
            if a <= 0:
                # A empty first
                return 1.0
            if b <= 0:
                # B empty first
                return 0.0
            
            # Calculate probability for each operation
            prob = 0.25 * (
                helper(a - 4, b, memo) +      # pour 100mL A, 0mL B
                helper(a - 3, b - 1, memo) +  # pour 75mL A, 25mL B
                helper(a - 2, b - 2, memo) +  # pour 50mL A, 50mL B
                helper(a - 1, b - 3, memo)    # pour 25mL A, 75mL B
            )
            
            memo[(a, b)] = prob
            return prob
        
        # Convert n to units of 25mL and round up
        units = (n + 24) // 25
        return helper(units, units, {})
```