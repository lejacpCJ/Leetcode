# 869. Reordered Power of 2

## Problem Info

- **Difficulty:** Medium
- **Topics:** Hash Table, Math, Sorting, Counting, Enumeration
- [Link to the problem](https://leetcode.com/problems/reordered-power-of-2/)

## Description

You are given an integer `n`. We reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return `true` if and only if we can do this so that the resulting number is a power of two.

## Examples

- Input: `n = 1`
- Output: `true`

- Input: `n = 10`
- Output: `false`

## Constraints

- `1 <= n <= 10^9`

---

## Solution

1. **Generate all powers of 2**: Create a set of all possible powers of 2 within the constraint range (2^0 to 2^30)
2. **Sort digits**: Sort the digits of each power of 2 to create a canonical representation
3. **Compare with input**: Sort the digits of the input number and check if it matches any power of 2

**Complexity:**

- **Time:** O(log n), where n is the input number (for sorting digits and set lookup)
- **Space:** O(1), as we store at most 31 powers of 2 (constant space)

**Python Code:**

```python
class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        # Generate all powers of 2 from 2^0 to 2^30 
        # Sort the digits of each power of 2 and store in a set for O(1) lookup
        power_sorted = set(''.join(sorted(str(1 << i))) for i in range(31))
        
        # Sort the digits of the input number to get canonical representation
        n_sorted = ''.join(sorted(str(n)))
        
        # Check if the sorted digits of n match any sorted digits of powers of 2
        return n_sorted in power_sorted
```