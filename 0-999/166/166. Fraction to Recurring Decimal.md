# 166. Fraction to Recurring Decimal

**Difficulty:** Medium  
**Topics:** Hash Table, Math, String  
[Link to the problem](https://leetcode.com/problems/fraction-to-recurring-decimal/)

## Problem

Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

If multiple answers are possible, return any of them.

It is guaranteed that the length of the answer string is less than 10^4 for all the given inputs.

## Examples

- Input: numerator = 1, denominator = 2  
  Output: "0.5"

- Input: numerator = 2, denominator = 1  
  Output: "2"

- Input: numerator = 4, denominator = 333  
  Output: "0.(012)"

## Constraints

- -2^31 <= numerator, denominator <= 2^31 - 1
- denominator != 0

---

## Solution

1. Handle sign: result is negative iff numerator and denominator have opposite signs and numerator != 0.
2. Use integer division to get the integer part: quotient = abs(numerator) // abs(denominator).
3. If remainder is 0, return integer part (with sign).
4. For fractional part, perform long division: at each step multiply remainder by 10, get digit = remainder // denom, update remainder = remainder % denom.
5. Use a hash map (remainder -> position in result string) to detect when a remainder repeats; when it does, insert parentheses around the repeating substring.
6. Return the assembled string.

**Complexity:**

- Time: O(k) where k is number of digits generated before termination or cycle detection.
- Space: O(k) for the map and fractional digits.

## Python Implementation

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator == 0:
            return "0"
        sign = "-" if (numerator < 0) ^ (denominator < 0) else ""
        n, d = abs(numerator), abs(denominator)

        integer_part = n // d
        rem = n % d
        if rem == 0:
            return sign + str(integer_part)

        res = [sign + str(integer_part), "."]

        # map remainder -> index in res where the corresponding digit was appended
        seen = {}
        while rem != 0:
            if rem in seen:
                idx = seen[rem]
                # insert '(' at the recorded index and append ')' at the end
                res.insert(idx, "(")
                res.append(")")
                break
            seen[rem] = len(res)  # next digit will be placed at this index
            rem *= 10
            digit = rem // d
            res.append(str(digit))
            rem %= d

        return "".join(res)
```
