# 756. Pyramid Transition Matrix

## Problem Info

- **Difficulty:** Medium
- **Topics:** Hash Table, String, Backtracking, Bit Manipulation
- [Link to the problem](https://leetcode.com/problems/pyramid-transition-matrix/)

## Description

You are stacking blocks to form a pyramid. Each block has a color, represented by a single letter. Each row contains one less block than the row beneath it and is centered on top.

Only specific triangular patterns are allowed, given as a list of three-letter strings `allowed`, where the first two characters represent the left and right bottom blocks, and the third character is the top block.

Given a bottom row `bottom` (string) and the list `allowed`, return `true` if you can build the pyramid all the way to the top such that every triangular pattern is in `allowed`, or `false` otherwise.

## Examples

- Input: `bottom = "BCD"`, `allowed = ["BCC","CDE","CEA","FFF"]`
- Output: `true`
- Explanation: You can build "CE" on level 2 and "A" on level 1 using the allowed patterns.

- Input: `bottom = "AAAA"`, `allowed = ["AAB","AAC","BCD","BBE","DEF"]`
- Output: `false`
- Explanation: All possible ways get stuck before reaching the top.

## Constraints

- `2 <= bottom.length <= 6`
- `0 <= allowed.length <= 216`
- `allowed[i].length == 3`
- Letters are from `{'A', 'B', 'C', 'D', 'E', 'F'}`
- All values in `allowed` are unique

---

## Solution

1. **Build transitions map:** Map each (left, right) pair to possible top blocks.
2. **Recursive DFS with memoization:** Try to build the pyramid level by level, caching results.
3. **Backtracking:** For each level, try all possible combinations for the next level.
4. **Base case:** If the current level has only one block, return `True`.

**Complexity:**

- **Time:** O(6^bottom.length) in the worst case (since each pair can have up to 6 options, and bottom length â‰¤ 6)
- **Space:** O(6^bottom.length) for memoization

**Python Code:**

```python
from functools import cache
from collections import defaultdict
from itertools import pairwise, product
from typing import List

class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        # Build a mapping from (left_block, right_block) -> list of possible top blocks
        transitions_map = defaultdict(list)
        for transition in allowed:
            left_block, right_block, top_block = transition[0], transition[1], transition[2]
            transitions_map[left_block, right_block].append(top_block)

        @cache
        def can_build_pyramid(current_level: str) -> bool:
            # Base case: if we reach the top (single block), pyramid is complete
            if len(current_level) == 1:
                return True

            # Build all possible options for the next level
            next_level_options = []

            # For each adjacent pair in current level, find possible blocks above them
            for left_block, right_block in pairwise(current_level):
                possible_blocks = transitions_map[left_block, right_block]

                # If no valid block can be placed above this pair, pyramid cannot be built
                if not possible_blocks:
                    return False

                next_level_options.append(possible_blocks)

            # Try all combinations of blocks for the next level
            for next_level_combination in product(*next_level_options):
                next_level_string = ''.join(next_level_combination)
                if can_build_pyramid(next_level_string):
                    return True

            return False

        # Start building from the bottom
        return can_build_pyramid(bottom)
```
