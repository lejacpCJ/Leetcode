# 611. Valid Triangle Number

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Two Pointers, Binary Search, Greedy, Sorting
- [Link to the problem](https://leetcode.com/problems/valid-triangle-number/)

## Description

Given an integer array `nums`, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.

A triplet `(i, j, k)` can form a triangle if `nums[i] + nums[j] > nums[k]`, `nums[i] + nums[k] > nums[j]`, and `nums[j] + nums[k] > nums[i]`.

## Examples

- **Input:** `nums = [2,2,3,4]`  
  **Output:** `3`  
  **Explanation:** Valid combinations are:

  - `2,3,4` (using the first 2)
  - `2,3,4` (using the second 2)
  - `2,2,3`

- **Input:** `nums = [4,2,3,4]`  
  **Output:** `4`

## Constraints

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

---

## Solution

1. **Sort the array:** Sorting helps efficiently check the triangle condition.
2. **Fix the largest side:** For each possible largest side, use two pointers to find valid pairs.
3. **Count valid triplets:** For each pair, if the sum of the two smaller sides is greater than the largest, count all pairs between the pointers.

**Complexity:**

- **Time:** O(nÂ²), where n is the length of `nums`.
- **Space:** O(1), only uses variables for counting.

**Python Code:**

```python
from typing import List

class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        count = 0

        for k in range(n - 1, 1, -1):
            i, j = 0, k - 1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    count += j - i
                    j -= 1
                else:
                    i += 1
        return count
```
