# 407. Trapping Rain Water II

## Problem Info

- **Difficulty:** Hard
- **Topics:** Array, Breadth-First Search, Heap (Priority Queue), Matrix
- [Link to the problem](https://leetcode.com/problems/trapping-rain-water-ii/)

## Description

You are given an `m x n` integer matrix `heightMap` representing the height of each unit cell in a 2D elevation map. Return the volume of water it can trap after raining.

## Examples

- **Input:** `heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]`  
  **Output:** `4`  
  **Explanation:** After the rain, water is trapped between the blocks. We have two small ponds: 1 and 3 units trapped. The total volume of water trapped is 4.

- **Input:** `heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]`  
  **Output:** `10`

## Constraints

- `m == heightMap.length`
- `n == heightMap[i].length`
- `1 <= m, n <= 200`
- `0 <= heightMap[i][j] <= 2 * 10^4`

---

## Solution

1. **Use a Min-Heap (Priority Queue):**  
   Start by pushing all the border cells into a min-heap. These act as the "walls" for trapping water.

2. **BFS Traversal:**  
   Pop the lowest cell from the heap, and for each of its 4 neighbors, if the neighbor hasn't been visited, calculate the water it can trap (if any), and push the neighbor into the heap with the max of its height and the current cell's height.

3. **Mark Visited:**  
   Use a visited matrix to avoid revisiting cells.

**Complexity:**

- **Time:** O(m _ n _ log(m \* n)), since each cell is pushed/popped from the heap once.
- **Space:** O(m \* n), for the heap and visited matrix.

**Python Code:**

```python
from typing import List
import heapq

class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        if not heightMap or not heightMap[0]:
            return 0

        m, n = len(heightMap), len(heightMap[0])
        visited = [[False] * n for _ in range(m)]
        heap = []

        # Push all border cells into the heap
        for i in range(m):
            for j in [0, n-1]:
                heapq.heappush(heap, (heightMap[i][j], i, j))
                visited[i][j] = True
        for j in range(n):
            for i in [0, m-1]:
                if not visited[i][j]:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    visited[i][j] = True

        res = 0
        dirs = [(-1,0), (1,0), (0,-1), (0,1)]

        while heap:
            height, x, y = heapq.heappop(heap)
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
                    res += max(0, height - heightMap[nx][ny])
                    heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny))
                    visited[nx][ny] = True

        return res
```
