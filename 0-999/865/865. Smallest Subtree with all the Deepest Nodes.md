# 865. Smallest Subtree with all the Deepest Nodes

## Problem Info

- **Difficulty:** Medium
- **Topics:** Hash Table, Tree, Depth-First Search, Breadth-First Search, Binary Tree
- [Link to the problem](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/)

## Description

Given the root of a binary tree, the depth of each node is the shortest distance to the root.

Return the smallest subtree such that it contains all the deepest nodes in the original tree.

A node is called the deepest if it has the largest depth possible among any node in the entire tree.

The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node.

## Examples

- **Input:** `root = [3,5,1,6,2,0,8,null,null,7,4]`  
  **Output:** `[2,7,4]`  
  **Explanation:** The node with value 2 is the smallest subtree containing all deepest nodes (7 and 4).

- **Input:** `root = [1]`  
  **Output:** `[1]`  
  **Explanation:** The root is the deepest node.

- **Input:** `root = [0,1,3,null,2]`  
  **Output:** `[2]`  
  **Explanation:** The deepest node is 2.

## Constraints

- The number of nodes in the tree will be in the range `[1, 500]`.
- `0 <= Node.val <= 500`
- The values of the nodes in the tree are unique.

---

## Solution

1. **DFS Traversal:** For each node, recursively find the deepest node(s) in its left and right subtree.
2. **Compare Depths:** If left and right subtree depths are equal, current node is the lowest common ancestor of all deepest nodes.
3. **Return Subtree:** Return the node that is the root of the smallest subtree containing all deepest nodes.

**Complexity:**

- **Time:** O(n), where n is the number of nodes (each node is visited once).
- **Space:** O(h), where h is the height of the tree (due to recursion stack).

**Python Code:**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional

class Solution:
    def subtreeWithAllDeepest(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def dfs(node):
            if not node:
                return None, 0
            l_node, l_dist = dfs(node.left)
            r_node, r_dist = dfs(node.right)

            if l_dist > r_dist:
                return l_node, l_dist + 1
            if r_dist > l_dist:
                return r_node, r_dist + 1
            return node, l_dist + 1

        result_node, _ = dfs(root)
        return result_node
```
