# 2044. Count Number of Maximum Bitwise-OR Subsets

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Backtracking, Bit Manipulation, Enumeration
- [Link to the problem](https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/)

## Description

Given an integer array `nums`, find the maximum possible bitwise OR of a subset of `nums` and return the number of different non-empty subsets with the maximum bitwise OR.

An array `a` is a subset of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b`. Two subsets are considered different if the indices of the elements chosen are different.

The bitwise OR of an array `a` is equal to `a[0] OR a[1] OR ... OR a[a.length - 1]` (0-indexed).

## Examples

Input: `nums = [3,2,1,5]`  
Output: `6`  
Explanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:
- [3,5]
- [3,1,5] 
- [3,2,5]
- [3,2,1,5]
- [2,5]
- [2,1,5]

## Constraints

- `1 <= nums.length <= 16`
- `1 <= nums[i] <= 10^5`

---

## Solution

Use **backtracking** to enumerate all possible subsets and count those with maximum bitwise OR. Since the maximum OR is the OR of all elements, we can find it first and then count subsets achieving this value.

**Algorithm:**

1. **Find maximum OR**: Calculate the bitwise OR of all elements
2. **Backtrack through subsets**: For each, decide whether to include it or not
3. **Track current OR**: Maintain the OR value of the current subset
4. **Count valid subsets**: Increment counter when current OR equals maximum OR
5. **Return total count**: Sum of all subsets with maximum bitwise OR


**Complexity:**

- **Time:** O(2^n), where n is the length of nums (exploring all subsets).
- **Space:** O(n), for the recursion call stack.

**Python Code:**

```python
from typing import List

class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        max_or = 0
        for num in nums:
            max_or |= num
        
        def backtrack(index: int, current_or: int) -> int:
            if index == len(nums):
                return 1 if current_or == max_or else 0
            
            # Skip current element
            count = backtrack(index + 1, current_or)
            
            # Include current element
            count += backtrack(index + 1, current_or | nums[index])
            
            return count
        
        return backtrack(0, 0)
```
