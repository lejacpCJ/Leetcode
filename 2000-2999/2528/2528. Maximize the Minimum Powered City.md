# 2528. Maximize the Minimum Powered City

## Problem Info

- **Difficulty:** Hard
- **Topics:** Array, Binary Search, Greedy, Queue, Sliding Window, Prefix Sum
- [Link to the problem](https://leetcode.com/problems/maximize-the-minimum-powered-city/)

## Description

You are given a 0-indexed integer array `stations` of length `n`, where `stations[i]` represents the number of power stations in the `ith` city.

Each power station can provide power to every city in a fixed range. If the range is denoted by `r`, then a power station at city `i` can provide power to all cities `j` such that `|i - j| <= r` and `0 <= i, j <= n - 1`.

The power of a city is the total number of power stations it is being provided power from.

The government has sanctioned building `k` more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.

Given the two integers `r` and `k`, return the maximum possible minimum power of a city, if the additional power stations are built optimally.

Note that you can build the `k` power stations in multiple cities.

## Examples

- Input: `stations = [1,2,4,5,0]`, `r = 1`, `k = 2`
- Output: `5`
- Explanation:  
  One optimal way is to install both power stations at city 1.  
  So stations become `[1,4,4,5,0]`.

  - City 0: 1 + 4 = 5
  - City 1: 1 + 4 + 4 = 9
  - City 2: 4 + 4 + 5 = 13
  - City 3: 5 + 4 = 9
  - City 4: 5 + 0 = 5  
    The minimum power of a city is 5.

- Input: `stations = [4,4,4,4]`, `r = 0`, `k = 3`
- Output: `4`
- Explanation:  
  It can be proved that we cannot make the minimum power of a city greater than 4.

## Constraints

- `n == stations.length`
- `1 <= n <= 10^5`
- `0 <= stations[i] <= 10^5`
- `0 <= r <= n - 1`
- `0 <= k <= 10^9`

---

## Solution

1. **Prefix Sum:** Compute the initial power for each city using prefix sums.
2. **Binary Search:** Use binary search to find the maximum possible minimum power.
3. **Greedy Check:** For each candidate minimum power, greedily add stations where needed using a difference array for efficient range updates.

**Complexity:**

- **Time:** O(n log(maxPower)), where n is the number of cities.
- **Space:** O(n), for prefix sum and difference arrays.

**Python Code:**

```python
class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)
        # Compute prefix sum for fast range queries
        presum = [0] * (n + 1)
        for i in range(1, n + 1):
            presum[i] = presum[i - 1] + stations[i - 1]

        # Calculate initial power for each city
        power = [0] * n
        for i in range(n):
            # Power is sum of stations in [i-r, i+r]
            power[i] = presum[min(i + r + 1, n)] - presum[max(i - r, 0)]

        # Binary search for the maximum possible minimum power
        left = min(power)
        right = left + k
        while left <= right:
            mid = left + (right - left) // 2
            # Check if it's possible to achieve at least 'mid' power everywhere
            if self.check(mid, power, n, r, k):
                left = mid + 1
            else:
                right = mid - 1
        return right

    def check(self, minPower: int, power: List[int], n: int, r: int, k: int) -> bool:
        # Difference array for efficient range updates
        diff = [0] * n
        need = 0
        sumD = 0
        for i in range(n):
            sumD += diff[i]
            # Calculate how many more stations are needed at city i
            m = minPower - power[i] - sumD
            if m > 0:
                need += m
                if need > k:
                    return False  # Not enough stations left to allocate
                sumD += m
                # Remove the effect of added stations after their range ends
                if i + 2 * r + 1 < n:
                    diff[i + 2 * r + 1] -= m
        return True
```
