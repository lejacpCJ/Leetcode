# 2106. Maximum Fruits Harvested After at Most K Steps

## Problem Info

- **Difficulty:** Hard
- **Topics:** Array, Binary Search, Sliding Window, Prefix Sum
- [Link to the problem](https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/)

## Description

Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already sorted by `positioni` in ascending order, and each `positioni` is unique.

You are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.

Return the maximum total number of fruits you can harvest.

## Examples

**Example 1:**
- Input: `fruits = [[2,8],[6,3],[8,6]]`, `startPos = 5`, `k = 4`
- Output: `9`
- Explanation: The optimal way is to move right to position 6 and harvest 3 fruits, then move right to position 8 and harvest 6 fruits. You moved 3 steps and harvested 3 + 6 = 9 fruits in total.

**Example 2:**
- Input: `fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]]`, `startPos = 5`, `k = 4`
- Output: `14`
- Explanation: Harvest 7 fruits at starting position 5, move left to position 4 and harvest 1 fruit, move right to position 6 and harvest 2 fruits, move right to position 7 and harvest 4 fruits. Total: 7 + 1 + 2 + 4 = 14 fruits.

**Example 3:**
- Input: `fruits = [[0,3],[6,4],[8,5]]`, `startPos = 3`, `k = 2`
- Output: `0`
- Explanation: You can move at most k = 2 steps and cannot reach any position with fruits.

## Constraints

- `1 <= fruits.length <= 10^5`
- `fruits[i].length == 2`
- `0 <= startPos, positioni <= 2 * 10^5`
- `positioni-1 < positioni` for any `i > 0` (0-indexed)
- `1 <= amounti <= 10^4`
- `0 <= k <= 2 * 10^5`

---

## Solution

1. **Sliding window**: We maintain a window [left, right] of consecutive fruit positions
2. **Expand window**: Move right pointer and add fruits to our collection
3. **Calculate steps**: For range [left, right], we need:
   - `fruits[right][0] - fruits[left][0]` steps to traverse the range
   - Plus `min(|startPos - fruits[left][0]|, |startPos - fruits[right][0]|)` steps to reach the range
4. **Shrink window**: If total steps > k, remove fruits from left until valid
5. **Track maximum**: Keep track of the maximum fruits in any valid window

**Why this works:**

- The optimal path always forms a contiguous range of positions
- We try all possible ranges efficiently using sliding window
- For each range, we calculate the minimum steps using the insight that we should start from the closer end

**Complexity:**

- **Time:** O(n), where n is the number of fruit positions
- **Space:** O(1), only using constant extra space

**Python Code:**

```python
from typing import List

class Solution:
    def maxPointsOnALine(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        max_fruits = 0  # Maximum fruits we can collect
        left = 0        # Left pointer for sliding window
        current_sum = 0 # Current sum of fruits in the window
        
        # Iterate through all fruit positions with right pointer
        for right, (right_pos, right_amount) in enumerate(fruits):
            # Add current fruit to our collection
            current_sum += right_amount
            
            # Shrink window from left while range is not reachable within k steps
            while (
                left <= right and
                # Calculate minimum steps needed for current range [left, right]
                # Range distance + shorter distance from startPos to either end
                (right_pos - fruits[left][0] + 
                 min(abs(startPos - fruits[left][0]), abs(startPos - right_pos))) > k
            ):
                # Remove leftmost fruit and move left pointer
                current_sum -= fruits[left][1]
                left += 1
            
            # Update maximum fruits collected
            max_fruits = max(max_fruits, current_sum)
        
        return max_fruits
```
