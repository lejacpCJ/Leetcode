# 2327. Number of People Aware of a Secret

## Problem Info

- **Difficulty:** Medium
- **Topics:** Dynamic Programming, Queue, Simulation
- [Link to the problem](https://leetcode.com/problems/number-of-people-aware-of-a-secret/)

## Description

You are given three integers: `n`, `delay`, and `forget`.

- On day 1, one person discovers a secret.
- Each person will share the secret with a new person every day, starting from `delay` days after discovering the secret.
- Each person will forget the secret `forget` days after discovering it.
- A person cannot share the secret on the same day they forgot it, or on any day afterwards.

Return the number of people who know the secret at the end of day `n`. Since the answer may be very large, return it modulo $10^9 + 7$.

## Examples

- **Input:** `n = 6`, `delay = 2`, `forget = 4`  
  **Output:** `5`  
  **Explanation:**  
  - Day 1: A knows the secret. (1 person)
  - Day 2: Only A knows. (1 person)
  - Day 3: A shares with B. (2 people)
  - Day 4: A shares with C. (3 people)
  - Day 5: A forgets, B shares with D. (3 people)
  - Day 6: B shares with E, C shares with F. (5 people)

- **Input:** `n = 4`, `delay = 1`, `forget = 3`  
  **Output:** `6`  
  **Explanation:**  
  - Day 1: A knows. (1 person)
  - Day 2: A shares with B. (2 people)
  - Day 3: A and B share with C and D. (4 people)
  - Day 4: A forgets. B, C, D share with 3 new people. (6 people)

## Constraints

- `2 <= n <= 1000`
- `1 <= delay < forget <= n`

---

## Solution

1. **Dynamic Programming:**  
   Let `dp[i]` be the number of people who learn the secret on day `i`.  
   - On day 1, `dp[1] = 1`.
   - For each day `i`, every person who learned the secret on day `j` (`i - forget < j <= i - delay`) can share the secret on day `i`.
   - People forget the secret after `forget` days.

2. **Count People Who Know the Secret:**  
   At the end, sum all `dp[i]` for `n - forget + 1 <= i <= n` (people who haven't forgotten by day `n`).

## Detailed Explanation
### Variables

- `MOD = 10**9 + 7`: The result must be returned modulo $10^9 + 7$ to avoid large numbers.
- `dp[i]`: The number of people who **learn** the secret on day `i`.

### Initialization

- `dp = [0] * (n + 1)`: Create a list to store the number of new people who learn the secret each day (1-based index).
- `dp[1] = 1`: On day 1, only one person knows the secret.

### Main Loop

- For each `day` from 2 to `n`:
  - We want to find out how many people learn the secret on this day.
  - For this, we look at all previous days (`share_day`) where people are **eligible to share** the secret on `day`.
  - A person who learned the secret on `share_day` can start sharing after `delay` days, and forgets after `forget` days.
  - So, for each `share_day` in `[max(1, day - forget + 1), day - delay]`:
    - If `share_day` is in this range, those people can share the secret on `day`.
    - Add the number of people who learned the secret on `share_day` to `dp[day]`.

### Final Calculation

- At the end, not everyone who ever learned the secret still remembers it.
- Only people who learned the secret in the last `forget - 1` days (from day `n - forget + 1` to day `n`) still remember it.
- So, sum `dp[i]` for `i` in `[n - forget + 1, n]`.


**Complexity:**
- **Time:** O(n)
- **Space:** O(n)

**Python Code:**

```python
MOD = 10**9 + 7

class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        dp = [0] * (n + 1)
        dp[1] = 1

        for day in range(2, n + 1):
            for share_day in range(max(1, day - forget + 1), day - delay + 1):
                dp[day] = (dp[day] + dp[share_day]) % MOD

        # Sum people who still remember the secret at the end
        return sum(dp[max(1, n - forget + 1): n + 1]) % MOD
```
