# 2598. Smallest Missing Non-negative Integer After Operations

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Hash Table, Math, Greedy
- [Link to the problem](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/)

## Description

You are given a 0-indexed integer array `nums` and an integer `value`.

In one operation, you can add or subtract `value` from any element of `nums`.

For example, if `nums = [1,2,3]` and `value = 2`, you can choose to subtract `value` from `nums[0]` to make `nums = [-1,2,3]`.

The MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.

For example, the MEX of `[-1,2,3]` is `0` while the MEX of `[1,0,3]` is `2`.

Return the maximum MEX of `nums` after applying the mentioned operation any number of times.

## Examples

- **Example 1:**

  - Input: `nums = [1,-10,7,13,6,8]`, `value = 5`
  - Output: `4`
  - Explanation:  
    One can achieve this result by applying the following operations:
    - Add value to `nums[1]` twice to make `nums = [1,0,7,13,6,8]`
    - Subtract value from `nums[2]` once to make `nums = [1,0,2,13,6,8]`
    - Subtract value from `nums[3]` twice to make `nums = [1,0,2,3,6,8]`
      The MEX of `nums` is `4`. It can be shown that `4` is the maximum MEX we can achieve.

- **Example 2:**
  - Input: `nums = [1,-10,7,13,6,8]`, `value = 7`
  - Output: `2`
  - Explanation:  
    One can achieve this result by applying the following operation:
    - Subtract value from `nums[2]` once to make `nums = [1,-10,0,13,6,8]`
      The MEX of `nums` is `2`. It can be shown that `2` is the maximum MEX we can achieve.

## Constraints

- `1 <= nums.length, value <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

---

## Solution

1. **Observation:**  
   Any number can be transformed to any integer with the same remainder modulo `value` by adding or subtracting `value` any number of times.

2. **Approach:**

   - Count how many numbers in `nums` have each possible remainder modulo `value`.
   - The smallest MEX we cannot form is when, for some remainder `r`, we have used up all possible numbers for that remainder.
   - For each remainder, the count tells us how many times we can form numbers of the form `r + k * value`.
   - The answer is `min_mod * value + min_i`, where `min_mod` is the minimum count among all remainders, and `min_i` is the smallest remainder with that count.

3. **Complexity:**
   - **Time:** O(n + value)
   - **Space:** O(value)

**Python Code:**

```python
class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        mods = [0] * value
        for num in nums:
            mods[num % value] += 1
        min_mod = min(mods)
        min_i = mods.index(min_mod)
        return min_mod * value + min_i
```
