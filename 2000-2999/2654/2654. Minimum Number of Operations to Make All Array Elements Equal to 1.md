# 2654. Minimum Number of Operations to Make All Array Elements Equal to 1

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Math, Number Theory
- [Link to the problem](https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/)

## Description

You are given a 0-indexed array `nums` consisting of positive integers. You can do the following operation on the array any number of times:

- Select an index `i` such that `0 <= i < n - 1` and replace either `nums[i]` or `nums[i+1]` with their gcd value.

Return the minimum number of operations to make all elements of `nums` equal to 1. If it is impossible, return -1.

The gcd of two integers is the greatest common divisor of the two integers.

## Examples

- **Input:** `nums = [2,6,3,4]`  
  **Output:** `4`  
  **Explanation:**

  - Choose index `i = 2` and replace `nums[2]` with `gcd(3,4) = 1`. Now `nums = [2,6,1,4]`.
  - Choose index `i = 1` and replace `nums[1]` with `gcd(6,1) = 1`. Now `nums = [2,1,1,4]`.
  - Choose index `i = 0` and replace `nums[0]` with `gcd(2,1) = 1`. Now `nums = [1,1,1,4]`.
  - Choose index `i = 2` and replace `nums[3]` with `gcd(1,4) = 1`. Now `nums = [1,1,1,1]`.

- **Input:** `nums = [2,10,6,14]`  
  **Output:** `-1`  
  **Explanation:**  
  It is impossible to make all elements equal to 1.

## Constraints

- `2 <= nums.length <= 50`
- `1 <= nums[i] <= 10^6`

---

## Solution

1. **Check if possible:** If the gcd of all elements is not 1, it's impossible.
2. **Count existing ones:** If there are already ones, each non-one can be made 1 in one operation.
3. **Find shortest subarray with gcd 1:** For each subarray, find the shortest length where the gcd is 1.
4. **Calculate operations:** The minimum operations is `len(nums) + min_len - 2`.

**Complexity:**

- **Time:** O(nÂ²), where n is the length of `nums`.
- **Space:** O(1)

**Python Code:**

```python
import math

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        gcd_all = 0
        ones = 0
        min_len = 10 ** 6

        for num in nums:
            gcd_all = math.gcd(gcd_all, num)
            if num == 1:
                ones += 1
        if gcd_all != 1:
            return -1
        if ones > 0:
            return len(nums) - ones

        for i in range(len(nums)):
            curr_gcd = nums[i]
            for j in range(i+1, len(nums)):
                curr_gcd = math.gcd(curr_gcd, nums[j])
                if curr_gcd == 1:
                    min_len = min(min_len, j - i + 1)
                    break
        return len(nums) + min_len - 2
```
