# 2561. Rearranging Fruits

## Problem Info

- **Difficulty:** Hard
- **Topics:** Array, Hash Table, Greedy, Sorting
- [Link to the problem](https://leetcode.com/problems/rearranging-fruits/)

## Description

You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays `basket1` and `basket2` representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:

- Choose two indices `i` and `j`, and swap the `ith` fruit of `basket1` with the `jth` fruit of `basket2`.
- The cost of the swap is `min(basket1[i], basket2[j])`.

Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.

Return the minimum cost to make both the baskets equal or `-1` if impossible.

## Examples

- Input: `basket1 = [2,3,4,1]`, `basket2 = [3,2,5,1]`
- Output: `-1`
- Explanation: It can be shown that it is impossible to make both the baskets equal.

## Constraints

- `basket1.length == basket2.length`
- `1 <= basket1.length <= 10^5`
- `1 <= basket1[i], basket2[i] <= 10^9`

---

## Solution

**Steps:**

1. **Count frequencies**: Count the frequency of each fruit type in both baskets combined
2. **Check possibility**: If any fruit type has an odd total count, return -1 (impossible to split evenly)
3. **Identify excess fruits**: For each basket, find which fruits are in excess (more than half the total count)
4. **Calculate minimum swaps**: Use greedy approach to pair excess fruits optimally
5. **Consider indirect swaps**: Sometimes swapping through the minimum element is cheaper than direct swaps

**Key Insights:**

- For baskets to be equal, each fruit type must appear an even number of times total
- We only need to swap excess fruits from each basket
- Direct swap cost: `min(fruit1, fruit2)`
- Indirect swap cost: `2 * min_element` (swap both fruits with the minimum element)

**Complexity:**

- **Time:** O(n log n), due to sorting the excess fruits
- **Space:** O(n), for storing frequency counts and excess fruits

**Python Code:**

```python
from typing import List
from collections import Counter

class Solution:
    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        # Count frequency of each fruit type in both baskets
        count = Counter(basket1 + basket2)
        count1, count2 = Counter(basket1), Counter(basket2)
        all_keys = set(count1.keys()).union(count2.keys())
        # Find excess fruits in each basket
        excess1, excess2 = [], []

        # Check if it's possible to make baskets equal
        for key in all_keys:
            if (count1[key] + count2[key]) % 2 == 1:
                return -1
            target = (count1[key] + count2[key]) // 2
            if count1[key] > target:
                excess1.extend([key] * (count1[key] - target))
            if count2[key] > target:
                excess2.extend([key] * (count2[key] - target))
        
        # Sort excess fruits for optimal pairing
        excess1.sort()
        excess2.sort(reverse=True)
        
        # Find minimum element for indirect swaps
        min_element = min(basket1 + basket2)
        
        total_cost = 0
        for i in range(len(excess1)):
            # Direct swap vs indirect swap (through min element)
            direct_cost = min(excess1[i], excess2[i])
            indirect_cost = 2 * min_element
            total_cost += min(direct_cost, indirect_cost)
        
        return total_cost
```