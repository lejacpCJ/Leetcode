# 2300. Successful Pairs of Spells and Potions

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Two Pointers, Binary Search, Sorting
- [Link to the problem](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/)

## Description

You are given two positive integer arrays `spells` and `potions`, of length `n` and `m` respectively, where `spells[i]` represents the strength of the `i`th spell and `potions[j]` represents the strength of the `j`th potion.

You are also given an integer `success`. A spell and potion pair is considered successful if the product of their strengths is at least `success`.

Return an integer array `pairs` of length `n` where `pairs[i]` is the number of potions that will form a successful pair with the `i`th spell.

## Examples

- **Input:** `spells = [5,1,3]`, `potions = [1,2,3,4,5]`, `success = 7`  
  **Output:** `[4,0,3]`  
  **Explanation:**

  - 0th spell: 5 \* [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.
  - 1st spell: 1 \* [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
  - 2nd spell: 3 \* [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.
    Thus, `[4,0,3]` is returned.

- **Input:** `spells = [3,1,2]`, `potions = [8,5,8]`, `success = 16`  
  **Output:** `[2,0,2]`  
  **Explanation:**
  - 0th spell: 3 \* [8,5,8] = [24,15,24]. 2 pairs are successful.
  - 1st spell: 1 \* [8,5,8] = [8,5,8]. 0 pairs are successful.
  - 2nd spell: 2 \* [8,5,8] = [16,10,16]. 2 pairs are successful.
    Thus, `[2,0,2]` is returned.

## Constraints

- `n == spells.length`
- `m == potions.length`
- `1 <= n, m <= 10^5`
- `1 <= spells[i], potions[i] <= 10^5`
- `1 <= success <= 10^10`

---

## Solution

1. **Sort the potions array** to enable binary search.
2. **For each spell**, calculate the minimum potion strength needed for a successful pair:  
   `min_needed = ceil(success / spell) = (success + spell - 1) // spell`
3. **Use binary search** (`bisect_left`) to find the first potion that meets or exceeds `min_needed`.
4. **Count** the number of potions from that index to the end (`m - idx`).
5. **Repeat** for all spells.

**Complexity:**

- **Time:** O(n log m), where n is the number of spells and m is the number of potions.
- **Space:** O(m) for sorting potions.

**Python Code:**

```python
from typing import List
from bisect import bisect_left

class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        m = len(potions)
        res = []

        for spell in spells:
            min_needed = (success + spell - 1) // spell  # Ceiling division
            idx = bisect_left(potions, min_needed)
            res.append(m - idx)

        return res
```
