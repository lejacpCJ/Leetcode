# 2787. Ways to Express an Integer as Sum of Powers

## Problem Info

- **Difficulty:** Medium
- **Topics:** Dynamic Programming
- [Link to the problem](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/)

## Description

Given two positive integers `n` and `x`.

Return the number of ways `n` can be expressed as the sum of the `x`th power of unique positive integers, in other words, the number of sets of unique integers `[n1, n2, ..., nk]` where `n = n1^x + n2^x + ... + nk^x`.

Since the result can be very large, return it modulo `10^9 + 7`.

For example, if `n = 160` and `x = 3`, one way to express n is `n = 2^3 + 3^3 + 5^3`.

## Examples

- Input: `n = 10, x = 2`
- Output: `1`
- Explanation: We can express n as the following: `n = 3^2 + 1^2 = 10`. It can be shown that it is the only way to express 10 as the sum of the 2nd power of unique integers.

- Input: `n = 4, x = 1`
- Output: `2`
- Explanation: We can express n in the following ways:
  - `n = 4^1 = 4`
  - `n = 3^1 + 1^1 = 4`

## Constraints

- `1 <= n <= 300`
- `1 <= x <= 5`

---

## Solution

1. **Calculate maximum base**: Find the largest integer whose `x`th power doesn't exceed `n`
2. **Generate powers**: Create an array of all possible `x`th powers up to the maximum base
3. **Dynamic Programming**: Use a DP array where `dp[i]` represents the number of ways to form sum `i`
4. **Fill DP table**: For each power, update the DP array by considering including that power in the sum
5. **Return result**: The answer is stored in `dp[n]`

**Complexity:**

- **Time:** O(n Ã— k), where k is the number of valid powers (at most n^(1/x))
- **Space:** O(n), for the DP array

**Python Code:**

```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10**9 + 7
        
        # Find maximum base whose x-th power <= n
        epsilon = 1e-9
        max_n = int(n ** (1/x) + epsilon)

        # Generate all x-th powers: 1^x, 2^x, ..., max_n^x
        nums = [val ** x for val in range(1, max_n + 1)]

        # dp[i] = number of ways to express i as sum of unique x-th powers
        dp = [0] * (n + 1)
        dp[0] = 1  # Base case: one way to make 0

        # For each power, update dp array (iterate backwards to avoid reuse)
        for num in nums:
            for target in range(n, num - 1, -1):
                dp[target] = (dp[target] + dp[target - num]) % MOD

        return dp[n]
```