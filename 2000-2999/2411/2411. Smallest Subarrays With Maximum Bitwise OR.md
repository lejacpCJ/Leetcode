# 2411. Smallest Subarrays With Maximum Bitwise OR

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Bit Manipulation, Sliding Window
- [Link to the problem](https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/)

## Description

You are given a 0-indexed array `nums` of length `n`, consisting of non-negative integers. For each index `i`, you must determine the length of the shortest subarray starting at index `i` such that the bitwise OR of that subarray is the maximum possible.

In other words, let `maxOr` be the maximum value of the bitwise OR of any subarray starting at index `i`. You need to find the length of the shortest subarray starting at `i` with a bitwise OR equal to `maxOr`.

Return an array `answer` of length `n` where `answer[i]` is the length of the shortest subarray starting at `i` with maximum bitwise OR.

A subarray is a contiguous non-empty sequence of elements within an array.

## Example

Input: `nums = [1,0,2,1,3]`  
Output: `[3,3,2,2,1]`  
Explanation: 
- For index 0: The maximum OR of subarrays starting at 0 is 3, achieved by [1,0,2]. Length = 3.
- For index 1: The maximum OR of subarrays starting at 1 is 3, achieved by [0,2,1]. Length = 3.
- For index 2: The maximum OR of subarrays starting at 2 is 3, achieved by [2,1]. Length = 2.
- For index 3: The maximum OR of subarrays starting at 3 is 3, achieved by [1,3]. Length = 2.
- For index 4: The maximum OR of subarrays starting at 4 is 3, achieved by [3]. Length = 1.

## Constraints

- `n == nums.length`
- `1 <= n <= 10^5`
- `0 <= nums[i] <= 10^9`

---

## Solution

**Steps:**

The key insight is to work backwards from right to left, maintaining the rightmost positions where each bit is set. This allows us to efficiently determine the shortest subarray starting at each position that achieves the maximum possible bitwise OR.

1. **Initialize tracking arrays**: 
   - `bit_positions`: Array of size 32 to track the rightmost position where each bit (0-31) is set
   - `result`: Array to store the answer for each starting position

2. **Process from right to left**: 
   - For each position `i`, iterate through all 32 possible bit positions
   - If the current number `nums[i]` has a bit set at position `bit`, update `bit_positions[bit] = i`

3. **Calculate minimum subarray length**:
   - The maximum OR starting at position `i` includes all bits that appear in any subarray starting from `i`
   - To achieve this maximum OR, we need to extend the subarray to include the rightmost occurrence of each bit
   - The required length is `max(bit_positions) - i + 1` (distance to furthest bit position)
   - Use `max(1, ...)` to ensure minimum length is 1 (single element subarray)

**Complexity:**  

- **Time:** O(n Ã— 32) = O(n), since we iterate through the array once and check 32 bits for each element  
- **Space:** O(n), for the result array

**Python Code:**

```python
from typing import List

class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        # Store the rightmost position where each bit is set
        bit_positions = [0] * 32
        result = [0] * n
        
        # Process from right to left
        for i in range(n - 1, -1, -1):
            # Update bit positions for current number
            for bit in range(32):
                if nums[i] & (1 << bit):
                    bit_positions[bit] = i
            
            # Find the furthest bit position needed for maximum OR
            # This determines the minimum subarray length
            result[i] = max(1, max(bit_positions) - i + 1)

        return result
```
        