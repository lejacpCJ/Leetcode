# 3003. Maximize the Number of Partitions After Operations

## Problem Info

- **Difficulty:** Hard
- **Topics:** String, Dynamic Programming, Bit Manipulation, Bitmask
- [Link to the problem](https://leetcode.com/problems/maximize-the-number-of-partitions-after-operations/)

## Description

You are given a string `s` and an integer `k`.

First, you are allowed to change at most one index in `s` to another lowercase English letter.

After that, do the following partitioning operation until `s` is empty:

- Choose the longest prefix of `s` containing at most `k` distinct characters.
- Delete the prefix from `s` and increase the number of partitions by one. The remaining characters (if any) in `s` maintain their initial order.

Return an integer denoting the maximum number of resulting partitions after the operations by optimally choosing at most one index to change.

## Examples

### Example 1

- **Input:** `s = "accca"`, `k = 2`
- **Output:** `3`
- **Explanation:**
  - The optimal way is to change `s[2]` to something other than `a` and `c`, for example, `b`. Then it becomes `"acbca"`.
  - Partitioning steps:
    1. The longest prefix with at most 2 distinct characters is `"ac"`, remove it, `s = "bca"`.
    2. Next, `"bc"` is the longest prefix, remove it, `s = "a"`.
    3. Remove `"a"`, `s` is empty.
  - Total partitions: **3**.

### Example 2

- **Input:** `s = "aabaab"`, `k = 3`
- **Output:** `1`
- **Explanation:**
  - Initially, `s` contains only 2 distinct characters. Any change will not increase the number of distinct characters above 3, so the whole string is always a valid prefix. Only 1 partition is possible.

### Example 3

- **Input:** `s = "xxyz"`, `k = 1`
- **Output:** `4`
- **Explanation:**
  - The optimal way is to change `s[0]` or `s[1]` to a new character, e.g., change `s[0]` to `w` to get `"wxyz"`.
  - Now, each character is unique, and with `k = 1`, each character forms its own partition.
  - Total partitions: **4**.

## Constraints

- `1 <= s.length <= 10^4`
- `s` consists only of lowercase English letters.
- `1 <= k <= 26`

---

## Solution

1. **Bitmask Representation:** Use bitmasks to efficiently track unique letters in prefixes and suffixes.
2. **Prefix & Suffix Partitioning:** For each index, precompute the number of partitions and unique letter masks for prefixes and suffixes.
3. **Try All Possible Changes:** For each index, simulate changing that character and calculate the resulting number of partitions.
4. **Combine Results:** For each possible change, combine the prefix and suffix information to maximize the number of partitions.

**Complexity:**

- **Time:** O(n), where n is the length of `s`.
- **Space:** O(n), for prefix and suffix arrays.

**Python Code:**

```python
from typing import List

class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        n = len(s)
        # Convert each character to a bitmask representing its unique letter
        letters_mask = [1 << (ord(letter) - ord("a")) for letter in s]

        # Helper function to compute prefix (or suffix) partition counts and unique letter masks
        def make_prefix(letters_mask: List[int]):
            prefix = [0]  # Number of partitions up to each position
            prefix_mask = [0]  # Bitmask of unique letters up to each position
            unique_letters_mask = 0
            partitions = 0
            for letter_mask in letters_mask:
                unique_letters_mask |= letter_mask  # Add this letter to the set
                # If unique letters exceed k, start a new partition
                if unique_letters_mask.bit_count() > k:
                    partitions += 1
                    unique_letters_mask = letter_mask  # Start new partition with current letter
                prefix.append(partitions)
                prefix_mask.append(unique_letters_mask)
            return prefix, prefix_mask

        # Compute prefix and suffix partition info
        prefix, prefix_mask = make_prefix(letters_mask)
        # For suffix, reverse the string and process similarly
        suffix, suffix_mask = make_prefix(letters_mask[::-1])

        max_partitions_after_operations = 0
        # Try changing each index to any other letter and calculate the resulting partitions
        for index in range(n):
            # Combine partitions from prefix and suffix (excluding current index)
            partitions = prefix[index] + suffix[-(index + 2)]
            # Bitmask of unique letters in left and right (excluding current index)
            unique_letters_mask = prefix_mask[index] | suffix_mask[-(index + 2)]
            # Case 1: If we can add a new unique letter at this index without exceeding k
            if min(unique_letters_mask.bit_count() + 1, 26) <= k:
                partitions += 1
            # Case 2: Both sides are full (k unique letters), and there is at least one letter not present
            elif (
                prefix_mask[index].bit_count()
                == suffix_mask[-(index + 2)].bit_count()
                == k
                and unique_letters_mask.bit_count() < 26
            ):
                partitions += 3
            # Case 3: Otherwise, flipping this index creates two partitions
            else:
                partitions += 2
            # Track the maximum partitions possible
            max_partitions_after_operations = max(
                max_partitions_after_operations, partitions
            )
        return max_partitions_after_operations
```
