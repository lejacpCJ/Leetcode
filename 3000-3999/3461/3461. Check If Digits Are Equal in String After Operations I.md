# 3461. Check If Digits Are Equal in String After Operations I

## Problem Info

- **Difficulty:** Easy
- **Topics:** Math, String, Simulation, Combinatorics, Number Theory
- **Link:** https://leetcode.com/problems/

## Description

You are given a string s consisting of digits. Perform the following operation repeatedly until the string has exactly two digits:

- For each pair of consecutive digits in s, starting from the first digit, calculate a new digit as the sum of the two digits modulo 10.
- Replace s with the sequence of newly calculated digits, maintaining the order in which they are computed.

Return true if the final two digits in s are the same; otherwise, return false.

## Examples

- Input: s = "3902"  
  Output: true  
  Explanation: After successive reductions s becomes "11", so return true.

- Input: s = "34789"  
  Output: false  
  Explanation: After reductions s becomes "48", digits differ, so return false.

## Constraints

- 3 <= s.length <= 100
- s consists of only digits.

---

## Solution

Idea: Each reduction step computes adjacent sums modulo 10. After repeated reductions down to two digits, each of the final two digits is a linear combination of the original digits with integer coefficients equal to certain binomial coefficients. We can precompute those coefficients (weights) and compare the two weighted sums modulo 10.

Steps:

1. Let n = len(s). Precompute weights = [C(n-2, i) for i in 0..n-2].
2. Compute left_weighted_sum = sum(int(s[i]) \* weights[i]) for i in 0..n-2.
3. Compute right_weighted_sum = sum(int(s[i+1]) \* weights[i]) for i in 0..n-2.
4. Return (left_weighted_sum - right_weighted_sum) % 10 == 0 (equivalently compare each modulo 10).

**Complexity:**

- Time: O(n) (computing n-1 combinations and two linear scans)
- Space: O(n) (weights array)

**Python Code:**

```python
import math

class Solution:
    def hasSameDigits(self, s: str) -> bool:
        n = len(s)
        if n < 2:
            return True

        # weights correspond to binomial coefficients C(n-2, i) for i in [0..n-2]
        weights = [math.comb(n - 2, i) for i in range(n - 1)]

        left_weighted_sum = sum(int(s[i]) * weights[i] for i in range(n - 1))
        right_weighted_sum = sum(int(s[i + 1]) * weights[i] for i in range(n - 1))

        return left_weighted_sum % 10 == right_weighted_sum % 10
```
