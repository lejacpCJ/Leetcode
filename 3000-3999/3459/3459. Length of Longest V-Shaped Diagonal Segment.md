# 3459. Length of Longest V-Shaped Diagonal Segment

## Problem Info

- **Difficulty:** Hard
- **Topics:** Array, Dynamic Programming, Memoization, Matrix
- [Link to the problem](https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/)

## Description

You are given a 2D integer matrix `grid` of size `n x m`, where each element is either 0, 1, or 2.

A **V-shaped diagonal segment** is defined as:

- The segment starts with `1`.
- The subsequent elements follow this infinite sequence:  
  - If the previous value is `1` or `0`, the next must be `2`.
  - If the previous value is `2`, the next must be `0`.
- The segment:
    - Starts along a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).
    - Continues the sequence in the same diagonal direction.
    - Makes at most one clockwise 90-degree turn to another diagonal direction while maintaining the sequence.

Return the length of the longest V-shaped diagonal segment. If no valid segment exists, return 0.

## Examples

- **Input:** `grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]`  
  **Output:** `5`  
  **Explanation:**  
  The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,2) → (1,3) → (2,4), takes a 90-degree clockwise turn at (2,4), and continues as (3,3) → (4,2).

- **Input:** `grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]`  
  **Output:** `4`  
  **Explanation:**  
  The longest V-shaped diagonal segment has a length of 4 and follows these coordinates: (2,3) → (3,2), takes a 90-degree clockwise turn at (3,2), and continues as (2,1) → (1,0).

- **Input:** `grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]`  
  **Output:** `5`  
  **Explanation:**  
  The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,0) → (1,1) → (2,2) → (3,3) → (4,4).

- **Input:** `grid = [[1]]`  
  **Output:** `1`  
  **Explanation:**  
  The longest V-shaped diagonal segment has a length of 1 and follows these coordinates: (0,0).

## Constraints

- `n == grid.length`
- `m == grid[i].length`
- `1 <= n, m <= 500`
- `grid[i][j]` is either 0, 1 or 2.

---

## Solution

1. **State Representation:**  
   Use dynamic programming with memoization. Each state is represented by `(row, col, direction, turn_made, prev_val)`, where:
   - `direction`: current diagonal direction (0: ↘, 1: ↙, 2: ↖, 3: ↗)
   - `turn_made`: whether a 90-degree turn has been made (0 or 1)
   - `prev_val`: the value at the previous cell (or 1 for the start)

2. **Transitions:**  
   - Continue in the same direction if the next cell matches the expected value (see sequence rule below).
   - If no turn has been made, try making a 90-degree clockwise turn to the next diagonal direction.

3. **Sequence Rule:**  
   - If previous value is `1` or `0`, expect `2`.
   - If previous value is `2`, expect `0`.

4. **Base Case:**  
   - Out of bounds or value does not match the expected sequence.

5. **Iterate:**  
   - Try starting from every cell with value 1 and all four diagonal directions.

**Complexity:**
- **Time:** O(n * m * 4 * 2), since each cell, direction, and turn state is visited at most once.
- **Space:** O(n * m * 4 * 2), for memoization.

**Python Code:**

```python
from typing import List
from functools import lru_cache

class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        # Diagonal directions: ↘, ↙, ↖, ↗ (clockwise order)
        dirs = [(1,1), (1,-1), (-1,-1), (-1,1)]

        @lru_cache(maxsize=None)
        def dp(x, y, d, turn, prev):
            if not (0 <= x < n and 0 <= y < m):
                return 0
            # Sequence rule
            if prev == 1 or prev == 0:
                expected = 2
            else:  # prev == 2
                expected = 0
            if grid[x][y] != expected:
                return 0
            res = 1
            # Continue in same direction
            nx, ny = x + dirs[d][0], y + dirs[d][1]
            res = max(res, 1 + dp(nx, ny, d, turn, grid[x][y]))
            # Try turning if not turned yet
            if turn == 0:
                nd = (d + 1) % 4  # 90-degree clockwise
                nx2, ny2 = x + dirs[nd][0], y + dirs[nd][1]
                res = max(res, 1 + dp(nx2, ny2, nd, 1, grid[x][y]))
            return res

        ans = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    for d in range(4):
                        nx, ny = i + dirs[d][0], j + dirs[d][1]
                        ans = max(ans, 1 + dp(nx, ny, d, 0, 1))
        return ans
```