# 3573. Best Time to Buy and Sell Stock V

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Dynamic Programming
- [Link to the problem](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/)

## Description

You are given an integer array `prices` where `prices[i]` is the price of a stock in dollars on the `i`th day, and an integer `k`.

You are allowed to make at most `k` transactions, where each transaction can be either of the following:

- Normal transaction: Buy on day `i`, then sell on a later day `j` where `i < j`. You profit `prices[j] - prices[i]`.
- Short selling transaction: Sell on day `i`, then buy back on a later day `j` where `i < j`. You profit `prices[i] - prices[j]`.

Note that you must complete each transaction before starting another. Additionally, you can't buy or sell on the same day you are selling or buying back as part of a previous transaction.

Return the maximum total profit you can earn by making at most `k` transactions.

## Examples

- Input: `prices = [1,7,9,8,2]`, `k = 2`
- Output: `14`
- Explanation:  
  We can make \$14 of profit through 2 transactions:

  - A normal transaction: buy the stock on day 0 for \$1 then sell it on day 2 for \$9, profit = `9 - 1 = 8`.
  - A short selling transaction: sell the stock on day 3 for \$8 then buy back on day 4 for \$2, profit = `8 - 2 = 6`.  
    Total profit = `8 + 6 = 14`.

- Input: `prices = [12,16,19,19,8,1,19,13,9]`, `k = 3`
- Output: `36`
- Explanation:  
  We can make \$36 of profit through 3 transactions:
  - Normal: buy on day 0 for \$12, sell on day 2 for \$19 → profit = `7`.
  - Short: sell on day 3 for \$19, buy back on day 4 for \$8 → profit = `11`.
  - Normal: buy on day 5 for \$1, sell on day 6 for \$19 → profit = `18`.  
    Total profit = `7 + 11 + 18 = 36`.

## Constraints

- `2 <= prices.length <= 10^3`
- `1 <= prices[i] <= 10^9`
- `1 <= k <= prices.length / 2`

---

## Solution

We use dynamic programming with three states describing whether we currently hold a position or not.

For each day `i` and for each number of **completed** transactions `t` (from `0` to `k`), we track:

- `flat[t]`: maximum profit at the end of day `i` with `t` completed transactions and **no open position**
- `long[t]`: maximum profit at the end of day `i` with `t` completed transactions and we are in the middle of a **normal** transaction (have bought, waiting to sell)
- `short[t]`: maximum profit at the end of day `i` with `t` completed transactions and we are in the middle of a **short** transaction (have sold, waiting to buy back)

Transitions on each day `i`:

1. From `flat[t]`:

   - Do nothing and stay flat: `flat[t]` stays the same.
   - If `t < k`, start a **normal** transaction by buying today: move to `long[t]` with value `flat[t] - prices[i]`.
   - If `t < k`, start a **short** transaction by selling today: move to `short[t]` with value `flat[t] + prices[i]`.

2. From `long[t]` (normal transaction running):

   - Keep holding: stay in `long[t]`.
   - Close the normal transaction by selling today: we complete one transaction and become flat with  
     `flat[t + 1] = max(flat[t + 1], long[t] + prices[i])`.

3. From `short[t]` (short transaction running):
   - Keep holding the short: stay in `short[t]`.
   - Close the short by buying back today: we complete one transaction and become flat with  
     `flat[t + 1] = max(flat[t + 1], short[t] - prices[i])`.

We roll arrays over days to keep the space complexity `O(k)`. Also, we never allow more than one operation per day, so we cannot close and open a transaction on the same day, which satisfies the “no buy/sell on the same day as closing” rule.

The answer is the maximum value of `flat[t]` over all `t <= k` after processing all days, since all open positions must be closed to count as completed transactions.

**Complexity:**

- **Time:** O(n \* k), where `n` is the number of days.
- **Space:** O(k) for the rolling DP arrays.

**Python Code:**

```python

from typing import List
import math

class Solution:
    def maximumProfit(self, prices: List[int], k: int) -> int:
        n = len(prices)
        if n == 0 or k == 0:
            return 0

        # DP arrays for current and previous day:
        # flat[t]  - no open position, t completed transactions
        # long[t]  - in a normal (long) transaction
        # short[t] - in a short transaction
        NEG_INF = -10**18

        prev_flat = [NEG_INF] * (k + 1)
        prev_long = [NEG_INF] * (k + 1)
        prev_short = [NEG_INF] * (k + 1)

        # Before day 0: flat with 0 completed transactions, profit = 0
        prev_flat[0] = 0

        for price in prices:
            cur_flat = [NEG_INF] * (k + 1)
            cur_long = [NEG_INF] * (k + 1)
            cur_short = [NEG_INF] * (k + 1)

            for t in range(k + 1):
                # 1) From flat[t]
                if prev_flat[t] != NEG_INF:
                    # Stay flat
                    cur_flat[t] = max(cur_flat[t], prev_flat[t])

                    if t < k:
                        # Start normal (buy today)
                        cur_long[t] = max(cur_long[t], prev_flat[t] - price)
                        # Start short (sell today)
                        cur_short[t] = max(cur_short[t], prev_flat[t] + price)

                # 2) From long[t] (normal running)
                if prev_long[t] != NEG_INF:
                    # Keep holding long
                    cur_long[t] = max(cur_long[t], prev_long[t])

                    # Close normal (sell today)
                    if t + 1 <= k:
                        cur_flat[t + 1] = max(cur_flat[t + 1], prev_long[t] + price)

                # 3) From short[t] (short running)
                if prev_short[t] != NEG_INF:
                    # Keep holding short
                    cur_short[t] = max(cur_short[t], prev_short[t])

                    # Close short (buy back today)
                    if t + 1 <= k:
                        cur_flat[t + 1] = max(cur_flat[t + 1], prev_short[t] - price)

            prev_flat, prev_long, prev_short = cur_flat, cur_long, cur_short

        # Best profit must be with no open position
        return max(prev_flat)
```
