# 3347. Maximum Frequency of an Element After Performing Operations II

## Problem Info

- **Difficulty:** Hard
- **Topics:** Array, Binary Search, Sliding Window, Sorting, Prefix Sum
- [Link to the problem](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/)

## Description

You are given an integer array `nums` and two integers `k` and `numOperations`.

You must perform an operation `numOperations` times on `nums`, where in each operation you:

- Select an index `i` that was not selected in any previous operations.
- Add an integer in the range `[-k, k]` to `nums[i]`.

Return the maximum possible frequency of any element in `nums` after performing the operations.

## Examples

- **Example 1:**

  - Input: `nums = [1,4,5]`, `k = 1`, `numOperations = 2`
  - Output: `2`
  - Explanation:  
    We can achieve a maximum frequency of two by:
    - Adding 0 to `nums[1]`, after which `nums` becomes `[1, 4, 5]`.
    - Adding -1 to `nums[2]`, after which `nums` becomes `[1, 4, 4]`.

- **Example 2:**
  - Input: `nums = [5,11,20,20]`, `k = 5`, `numOperations = 1`
  - Output: `2`
  - Explanation:  
    We can achieve a maximum frequency of two by:
    - Adding 0 to `nums[1]`.

## Constraints

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `0 <= k <= 10^9`
- `0 <= numOperations <= nums.length`

---

## Solution

1. **Candidate Generation:**  
   For each number, consider its possible values after adding or subtracting `k`. Collect all unique candidates.

2. **Mapping and Frequency:**  
   Map each candidate to an index. Count the frequency of each candidate in the original array.

3. **Prefix Sum:**  
   Build a prefix sum array for quick range queries.

4. **Sliding Window:**  
   For each candidate, use binary search to find the range of candidates within `k` distance. Calculate how many elements can be changed to this candidate using at most `numOperations` operations.

**Complexity:**

- **Time:** O(n log n), where n is the length of `nums` (due to sorting and binary search).
- **Space:** O(n), for storing candidates and prefix sums.

**Python Code:**

```python
import bisect

class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        candidates = list(nums)
        for num in nums:
            candidates.append(num + k)
            candidates.append(num - k)

        candidates = sorted(set(candidates))
        maps = {val: idx for idx, val in enumerate(candidates)}
        n = len(candidates)
        freq = [0] * n
        prefix_sum = [0] * (n + 1)
        for num in nums:
            freq[maps[num]] += 1

        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + freq[i - 1]

        max_freq = 1

        for i in range(n):
            left = bisect.bisect_left(candidates, candidates[i] - k)
            right = bisect.bisect_right(candidates, candidates[i] + k)

            changeable = prefix_sum[right] - prefix_sum[left] - freq[i]
            max_freq = max(max_freq, min(changeable, numOperations) + freq[i])

        return max_freq
```
