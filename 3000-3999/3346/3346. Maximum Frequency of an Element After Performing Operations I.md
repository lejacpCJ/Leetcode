# 3346. Maximum Frequency of an Element After Performing Operations I

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Binary Search, Sliding Window, Sorting, Prefix Sum
- [Link to the problem](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/)

## Description

(You are given an integer array `nums` and two integers `k` and `numOperations`.

You must perform an operation `numOperations` times on `nums`, where in each operation you:

- Select an index `i` that was not selected in any previous operations.
- Add an integer in the range `[-k, k]` to `nums[i]`.

Return the maximum possible frequency of any element in `nums` after performing the operations.)

## Examples

(- Input: `nums = [1,4,5]`, `k = 1`, `numOperations = 2`

- Output: `2`
- Explanation:

  - Add `0` to `nums[1]` → `[1, 4, 5]`
  - Add `-1` to `nums[2]` → `[1, 4, 4]`
  - The maximum frequency is `2` (for the element `4`).

- Input: `nums = [5,11,20,20]`, `k = 5`, `numOperations = 1`
- Output: `2`
- Explanation:
  - Add `0` to `nums[1]` → `[5, 11, 20, 20]`
  - The maximum frequency is `2` (for the element `20`).)

## Constraints

(- `1 <= nums.length <= 10^5`

- `1 <= nums[i] <= 10^5`
- `0 <= k <= 10^5`
- `0 <= numOperations <= nums.length`)

---

## Solution

(1. **Sort the array**: Sorting helps to group similar numbers together. 2. **Sliding window**: For each possible target value, try to make as many elements equal to it as possible using at most `numOperations` changes, each within `[-k, k]`. 3. **Prefix sum**: Use prefix sums to efficiently calculate the number of elements that can be changed to the target value. 4. **Window expansion**: Only elements within `k` of the target can be converted in one operation.)

**Complexity:**

- **Time:** (O(n log n), due to sorting and sliding window)
- **Space:** (O(n), for prefix sums)

**Python Code:**

```python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        # Find the maximum value in nums to size the frequency and prefix sum arrays
        max_num = max(nums)
        freq = [0] * max_num  # Frequency of each number in nums
        prefix_sum = [0] * (max_num + 1)  # Prefix sum of frequencies

        # Count frequency of each number
        for num in nums:
            freq[num - 1] += 1

        # Build prefix sum array for quick range queries
        for i in range(1, max_num + 1):
            prefix_sum[i] = prefix_sum[i - 1] + freq[i - 1]

        max_freq = 1  # Initialize result

        # Try each possible target value
        for target in range(max_num):
            left = max(0, target - k)  # Left bound of changeable range
            right = min(max_num - 1, target + k)  # Right bound of changeable range

            # Number of elements in [left, right] except the target itself
            changeable = prefix_sum[right + 1] - prefix_sum[left] - freq[target]

            # Update max_freq with the best possible frequency for this target
            max_freq = max(max_freq, min(changeable, numOperations) + freq[target])

        return max_freq
```
