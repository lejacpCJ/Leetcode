# 3321. Find X-Sum of All K-Long Subarrays II

## Problem Info

- **Difficulty:** Hard
- **Topics:** Array, Hash Table, Sliding Window, Heap (Priority Queue)
- [Link to the problem](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/)

## Description

You are given an array `nums` of `n` integers and two integers `k` and `x`.

The **x-sum** of an array is calculated by the following procedure:

1. Count the occurrences of all elements in the array.
2. Keep only the occurrences of the top `x` most frequent elements. If two elements have the same number of occurrences, the element with the bigger value is considered more frequent.
3. Calculate the sum of the resulting array.

Note: If an array has less than `x` distinct elements, its x-sum is the sum of the array.

Return an integer array `answer` of length `n - k + 1` where `answer[i]` is the x-sum of the subarray `nums[i..i + k - 1]`.

## Examples

- **Input:** `nums = [1,1,2,2,3,4,2,3]`, `k = 6`, `x = 2`
- **Output:** `[6,10,12]`
- **Explanation:**

  - For subarray `[1, 1, 2, 2, 3, 4]`, only elements 1 and 2 will be kept in the resulting array. Hence, `answer[0] = 1 + 1 + 2 + 2`.
  - For subarray `[1, 2, 2, 3, 4, 2]`, only elements 2 and 4 will be kept in the resulting array. Hence, `answer[1] = 2 + 2 + 2 + 4`. Note that 4 is kept in the array since it is bigger than 3 and 1 which occur the same number of times.
  - For subarray `[2, 2, 3, 4, 2, 3]`, only elements 2 and 3 are kept in the resulting array. Hence, `answer[2] = 2 + 2 + 2 + 3 + 3`.

- **Input:** `nums = [3,8,7,8,7,5]`, `k = 2`, `x = 2`
- **Output:** `[11,15,15,15,12]`
- **Explanation:** Since `k == x`, `answer[i]` is equal to the sum of the subarray `nums[i..i + k - 1]`.

## Constraints

- `nums.length == n`
- `1 <= n <= 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= x <= k <= nums.length`

---

## Solution

1. **Sliding Window:** Use a window of size `k` to process each subarray.
2. **Frequency Tracking:** Maintain the frequency of each element in the current window.
3. **Top-x Selection:** For each window, select the top `x` most frequent elements (breaking ties by larger value).
4. **Efficient Updates:** Use data structures like `SortedList` and `defaultdict` to efficiently update and query frequencies as the window slides.

### Details on `add_candidate` and `remove_candidate`:

- **add_candidate(cand):**

  - Adds a candidate tuple `(frequency, value)` to the `selected` list, which tracks the top `x` most frequent elements.
  - Updates the running sum (`skill_sum`) by adding the total contribution of this candidate (`frequency * value`).
  - If the number of candidates in `selected` exceeds `x`, the least frequent (and smallest value in case of tie) candidate is removed from `selected` and added to the `waitlist`. Its contribution is subtracted from `skill_sum`.

- **remove_candidate(cand):**
  - Removes a candidate from either `waitlist` or `selected`.
  - If removed from `selected`, its contribution is subtracted from `skill_sum`.
  - After removal, if there are candidates in the `waitlist`, the most frequent (and largest value in case of tie) candidate from `waitlist` is promoted to `selected`, and its contribution is added to `skill_sum`.

This mechanism ensures that at any time, `selected` contains the top `x` most frequent elements (with ties broken by value), and `skill_sum` reflects the sum of their occurrences in the current window.

**Complexity:**

- **Time:** O(n log x) (with efficient data structures for top-x selection)
- **Space:** O(n) (for frequency tracking and selection lists)

**Python Code:**

```python
from sortedcontainers import SortedList
from collections import defaultdict
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []

        # 'selected' keeps the top x most frequent (freq, value) pairs in the current window
        selected = SortedList()
        # 'waitlist' keeps the rest of the candidates not in top x
        waitlist = SortedList()
        # 'freq' maps each value to its frequency in the current window
        freq = defaultdict(int)
        # 'skill_sum' is the sum of all occurrences of the top x elements in the window
        skill_sum = 0

        def remove_candidate(cand):
            # Remove a candidate (freq, value) from waitlist or selected
            nonlocal skill_sum
            if cand in waitlist:
                # If candidate is in waitlist, just remove it
                waitlist.remove(cand)
                return
            if cand in selected:
                # If candidate is in selected, remove and update skill_sum
                selected.remove(cand)
                skill_sum -= cand[0] * cand[1]
                # After removal, promote the next best candidate from waitlist if available
                if waitlist:
                    new_selection = waitlist[-1]  # max of waitlist (highest freq, highest value)
                    waitlist.remove(new_selection)
                    selected.add(new_selection)
                    skill_sum += new_selection[0] * new_selection[1]

        def add_candidate(cand):
            # Add a candidate (freq, value) to selected and update skill_sum
            nonlocal skill_sum
            selected.add(cand)
            skill_sum += cand[0] * cand[1]
            # If selected exceeds x, demote the least frequent (and smallest value) to waitlist
            if len(selected) > x:
                rejection = selected[0]  # min of selected (lowest freq, lowest value)
                selected.remove(rejection)
                skill_sum -= rejection[0] * rejection[1]
                waitlist.add(rejection)

        for i in range(n):
            # Add the new element at position i to the window
            cand = (freq[nums[i]], nums[i])
            if freq[nums[i]] > 0:
                # If this value already exists, remove its old candidate before updating frequency
                remove_candidate(cand)
            freq[nums[i]] += 1
            cand = (freq[nums[i]], nums[i])
            # Add the updated candidate to selected/waitlist
            add_candidate(cand)

            if i >= k:
                # Remove the element that is sliding out of the window
                out_idx = i - k
                cand = (freq[nums[out_idx]], nums[out_idx])
                remove_candidate(cand)
                freq[nums[out_idx]] -= 1
                if freq[nums[out_idx]] > 0:
                    # If the outgoing value still exists in the window, re-add its updated candidate
                    cand = (freq[nums[out_idx]], nums[out_idx])
                    add_candidate(cand)

            if i >= k - 1:
                # When the window is full, record the current x-sum
                ans.append(skill_sum)
        return ans
```
