# 3408. Design Task Manager

## Problem Info

- **Difficulty:** Medium
- **Topics:** Hash Table, Design, Heap (Priority Queue), Ordered Set
- [Link to the problem](https://leetcode.com/problems/design-task-manager/)

## Description

You are given a task management system that allows users to manage their tasks, each associated with a priority. The system should efficiently handle adding, modifying, executing, and removing tasks.

Implement the `TaskManager` class:

- `TaskManager(vector<vector<int>>& tasks)` initializes the task manager with a list of user-task-priority triples. Each element is `[userId, taskId, priority]`.
- `void add(int userId, int taskId, int priority)` adds a task for the user.
- `void edit(int taskId, int newPriority)` updates the priority of an existing task.
- `void rmv(int taskId)` removes the task.
- `int execTop()` executes the task with the highest priority (if tie, highest taskId). Returns the userId of the executed task, or -1 if no tasks.

## Examples

```
Input:
["TaskManager", "add", "edit", "execTop", "rmv", "add", "execTop"]
[[[[1, 101, 10], [2, 102, 20], [3, 103, 15]]], [4, 104, 5], [102, 8], [], [101], [5, 105, 15], []]

Output:
[null, null, null, 3, null, null, 5]
```

**Explanation:**

- Initializes with three tasks for Users 1, 2, and 3.
- Adds task 104 for User 4.
- Updates priority of task 102.
- Executes task 103 for User 3.
- Removes task 101.
- Adds task 105 for User 5.
- Executes task 105 for User 5.

## Constraints

- `1 <= tasks.length <= 10^5`
- `0 <= userId, taskId <= 10^5`
- `0 <= priority, newPriority <= 10^9`
- At most `2 * 10^5` calls to methods.
- All taskId inputs are valid.

---

## Solution

We use a hash map to store task info and a max-heap to efficiently get the highest priority task. When editing or removing, we mark tasks as invalid in the map and skip them in the heap.

**Complexity:**
- **Time:** O(log n) per operation (heap push/pop)
- **Space:** O(n)

**Python Code:**

```python
import heapq

class TaskManager:
    def __init__(self, tasks):
        self.task_to_user_priority = {}
        self.task_heap = []
        for user, task, priority in tasks:
            self.task_to_user_priority[task] = (user, priority)
            heapq.heappush(self.task_heap, (-priority, -task))

    def add(self, userId, taskId, priority):
        self.task_to_user_priority[taskId] = (userId, priority)
        heapq.heappush(self.task_heap, (-priority, -taskId))

    def edit(self, taskId, newPriority):
        user, _ = self.task_to_user_priority[taskId]
        self.task_to_user_priority[taskId] = (user, newPriority)
        heapq.heappush(self.task_heap, (-newPriority, -taskId))

    def rmv(self, taskId):
        if taskId in self.task_to_user_priority:
            del self.task_to_user_priority[taskId]

    def execTop(self):
        while self.task_heap:
            neg_p, neg_t = heapq.heappop(self.task_heap)
            priority, task = -neg_p, -neg_t
            if task in self.task_to_user_priority and self.task_to_user_priority[task][1] == priority:
                user = self.task_to_user_priority[task][0]
                del self.task_to_user_priority[task]
                return user
        return -1
```