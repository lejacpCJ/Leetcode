# 3577. Count the Number of Computer Unlocking Permutations

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Permutations, Combinatorics
- [Link to the problem](https://leetcode.com/problems/count-the-number-of-computer-unlocking-permutations/)

## Description

You are given an array `complexity` of length `n`.

There are `n` locked computers in a room with labels from `0` to `n - 1`, each with its own unique password. The password of the computer `i` has a complexity `complexity[i]`.

The password for the computer labeled `0` is already decrypted and serves as the root. All other computers must be unlocked using it or another previously unlocked computer, following this information:

- You can decrypt the password for the computer `i` using the password for computer `j`, where `j` is any integer less than `i` with a lower complexity. (i.e. `j < i` and `complexity[j] < complexity[i]`)
- To decrypt the password for computer `i`, you must have already unlocked a computer `j` such that `j < i` and `complexity[j] < complexity[i]`.

Find the number of permutations of `[0, 1, 2, ..., n - 1]` that represent a valid order in which the computers can be unlocked, starting from computer `0` as the only initially unlocked one.

Since the answer may be large, return it modulo `10^9 + 7`.

Note that the password for the computer with label `0` is decrypted, and not the computer with the first position in the permutation.

## Examples

- Input: `complexity = [1,2,3]`
- Output: `2`
- Explanation:

  - The valid permutations are:
    - `[0, 1, 2]`: Unlock computer 0 first, then 1 (using 0), then 2 (using 1).
    - `[0, 2, 1]`: Unlock computer 0 first, then 2 (using 0), then 1 (using 0).

- Input: `complexity = [3,3,3,4,4,4]`
- Output: `0`
- Explanation:
  - There are no possible permutations which can unlock all computers.

## Constraints

- `2 <= complexity.length <= 10^5`
- `1 <= complexity[i] <= 10^9`

---

## Solution

1. **Check unlock possibility:** For each computer `i > 0`, if `complexity[0] >= complexity[i]`, it's impossible to unlock it, so return 0.
2. **Count valid permutations:** If all computers can be unlocked, the answer is `(n-1)!` (since computer 0 must be first).
3. **Modulo:** Return the result modulo `10^9 + 7`.

**Complexity:**

- **Time:** O(n) (for the check and factorial calculation)
- **Space:** O(1)

**Python Code:**

```python
class Solution:
    def countPermutations(self, complexity: List[int]) -> int:
        MOD = 10 ** 9 + 7
        n = len(complexity)
        for i in range(1, n):
            if complexity[0] >= complexity[i]:
                return 0
        # Compute factorial (n-1)!
        fact = 1
        for i in range(1, n):
            fact = (fact * i) % MOD
        return fact
```
