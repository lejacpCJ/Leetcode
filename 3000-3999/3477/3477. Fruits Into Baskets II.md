# 3477. Fruits Into Baskets II

## Problem Info

- **Difficulty:** Easy
- **Topics:** Array, Binary Search, Segment Tree
- [Link to the problem](https://leetcode.com/problems/fruits-into-baskets-ii/)

## Description

You are given two arrays of integers, `fruits` and `baskets`, each of length `n`, where `fruits[i]` represents the quantity of the `ith` type of fruit, and `baskets[j]` represents the capacity of the `jth` basket.

From left to right, place the fruits according to these rules:

- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.
- Each basket can hold only one type of fruit.
- If a fruit type cannot be placed in any basket, it remains result.

Return the number of fruit types that remain result after all possible allocations are made.

## Examples

- Input: `fruits = [3,6,1]`, `baskets = [6,4,7]`
- Output: `0`
- Explanation: `fruits[0] = 3` is placed in `baskets[0] = 6`. `fruits[1] = 6` cannot be placed in `baskets[1] = 4` (insufficient capacity) but can be placed in the next available basket, `baskets[2] = 7`. `fruits[2] = 1` is placed in `baskets[1] = 4`. Since all fruits are successfully placed, we return 0.

## Constraints

- `n == fruits.length == baskets.length`
- `1 <= n <= 100`
- `1 <= fruits[i], baskets[i] <= 1000`

---

## Solution

1. **Iterate through fruits**: Process each fruit type from left to right
2. **Find leftmost basket**: For each fruit, find the leftmost available basket with sufficient capacity
3. **Mark basket as used**: Once a basket is used, it cannot hold another fruit type
4. **Count result fruits**: Keep track of fruits that cannot be placed in any available basket

**Complexity:**

- **Time:** O(nÂ²), where n is the length of the arrays (for each fruit, we may check all baskets)
- **Space:** O(n), for the boolean array to track used baskets

**Python Code:**

```python
from typing import List

class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        result = 0
        
        # Process each fruit type from left to right
        for fruit in fruits:
            placed = False
            
            # Find the leftmost available basket with sufficient capacity
            for i, basket in enumerate(baskets):
                if basket != -1 and basket >= fruit:
                    baskets[i] = -1  # Mark basket as used
                    placed = True
                    break
            
            # If fruit couldn't be placed, increment result counter
            if not placed:
                result += 1
        
        return result
```