# 3652. Best Time to Buy and Sell Stock using Strategy

## Problem Info

- **Difficulty:** Medium
- **Topics:** Array, Sliding Window, Prefix Sum
- [Link to the problem](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-using-strategy/)

## Description

You are given two integer arrays `prices` and `strategy`, where:

- `prices[i]` is the price of a given stock on the `i`th day.
- `strategy[i]` represents a trading action on the `i`th day, where:
  - `-1` indicates buying one unit of the stock.
  - `0` indicates holding the stock.
  - `1` indicates selling one unit of the stock.

You are also given an even integer `k`, and may perform at most one modification to `strategy`. A modification consists of:

- Selecting exactly `k` consecutive elements in `strategy`.
- Set the first `k / 2` elements to `0` (hold).
- Set the last `k / 2` elements to `1` (sell).

The profit is defined as the sum of `strategy[i] * prices[i]` across all days.

Return the maximum possible profit you can achieve.

**Note:** There are no constraints on budget or stock ownership, so all buy and sell operations are feasible regardless of past actions.

## Examples

### Example 1

- **Input:** `prices = [4,2,8]`, `strategy = [-1,0,1]`, `k = 2`
- **Output:** `10`
- **Explanation:**

| Modification  | Strategy   | Profit Calculation               | Profit |
| ------------- | ---------- | -------------------------------- | ------ |
| Original      | [-1, 0, 1] | (-1 × 4) + (0 × 2) + (1 × 8) = 4 | 4      |
| Modify [0, 1] | [0, 1, 1]  | (0 × 4) + (1 × 2) + (1 × 8) = 10 | 10     |
| Modify [1, 2] | [-1, 0, 1] | (-1 × 4) + (0 × 2) + (1 × 8) = 4 | 4      |

Thus, the maximum possible profit is 10, which is achieved by modifying the subarray `[0, 1]`.

### Example 2

- **Input:** `prices = [5,4,3]`, `strategy = [1,1,0]`, `k = 2`
- **Output:** `9`
- **Explanation:**

| Modification  | Strategy  | Profit Calculation              | Profit |
| ------------- | --------- | ------------------------------- | ------ |
| Original      | [1, 1, 0] | (1 × 5) + (1 × 4) + (0 × 3) = 9 | 9      |
| Modify [0, 1] | [0, 1, 0] | (0 × 5) + (1 × 4) + (0 × 3) = 4 | 4      |
| Modify [1, 2] | [1, 0, 1] | (1 × 5) + (0 × 4) + (1 × 3) = 8 | 8      |

Thus, the maximum possible profit is 9, which is achieved without any modification.

## Constraints

- `2 <= prices.length == strategy.length <= 10^5`
- `1 <= prices[i] <= 10^5`
- `-1 <= strategy[i] <= 1`
- `2 <= k <= prices.length`
- `k` is even

---

## Solution

1. **Calculate the original profit:** Compute the sum of `strategy[i] * prices[i]` for all days.
2. **Sliding window for modification:** For each possible window of length `k`, simulate the modification:
   - Set the first `k/2` elements to `0` (hold).
   - Set the last `k/2` elements to `1` (sell).
3. **Efficient calculation:** Use prefix sums to efficiently compute the effect of the modification for each window.
4. **Track the maximum profit:** Return the maximum profit found.

**Complexity:**

- **Time:** O(n), where n is the length of the arrays.
- **Space:** O(n), for prefix sums.

**Python Code:**

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int], strategy: List[int], k: int) -> int:
        n = len(prices)
        m = k // 2

        # Compute prefix sums for efficient window calculations
        s1 = [0] * (n - m + 1)  # sum of strategy[i] * prices[i] for window of size m
        s2 = [0] * (n - m + 1)  # sum of prices[i] for window of size m

        s1[0] = sum(prices[i] * strategy[i] for i in range(m))
        s2[0] = sum(prices[i] for i in range(m))

        for i in range(n - m):
            s1[i + 1] = s1[i] - prices[i] * strategy[i] + prices[i + m] * strategy[i + m]
            s2[i + 1] = s2[i] - prices[i] + prices[i + m]

        total_profit = sum(prices[i] * strategy[i] for i in range(n))
        ans = total_profit

        for i in range(n - k + 1):
            # Remove the original profit in the window, add the profit after modification
            # First m elements set to 0, last m elements set to 1
            profit = total_profit - s1[i] - s1[i + m] + s2[i + m]
            ans = max(ans, profit)

        return ans
```
