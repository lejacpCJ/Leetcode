# 1970. Last Day Where You Can Still Cross

## Problem Info

- **Difficulty:** Hard
- **Topics:** Array, Binary Search, Depth-First Search, Breadth-First Search, Union Find, Matrix
- [Link to the problem](https://leetcode.com/problems/last-day-where-you-can-still-cross/)

## Description

You are given a 1-based binary matrix where `0` represents land and `1` represents water. The matrix has `row` rows and `col` columns. Initially, all cells are land. Each day, a new cell becomes flooded with water according to the array `cells`, where `cells[i] = [ri, ci]` means that on the `i`th day, the cell at row `ri` and column `ci` becomes water.

You want to find the last day it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row, moving only in the four cardinal directions (up, down, left, right).

Return the last day where it is possible to walk from the top to the bottom by only walking on land cells.

## Examples

### Example 1

- **Input:** `row = 2`, `col = 2`, `cells = [[1,1],[2,1],[1,2],[2,2]]`
- **Output:** `2`
- **Explanation:**  
  The matrix changes each day as follows:
  - Day 0: all land
  - Day 1: (1,1) flooded
  - Day 2: (2,1) flooded  
    The last day you can cross from top to bottom is day 2.

### Example 2

- **Input:** `row = 2`, `col = 2`, `cells = [[1,1],[1,2],[2,1],[2,2]]`
- **Output:** `1`
- **Explanation:**  
  The last day you can cross is day 1.

### Example 3

- **Input:** `row = 3`, `col = 3`, `cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]`
- **Output:** `3`
- **Explanation:**  
  The last day you can cross is day 3.

## Constraints

- `2 <= row, col <= 2 * 10^4`
- `4 <= row * col <= 2 * 10^4`
- `cells.length == row * col`
- `1 <= ri <= row`
- `1 <= ci <= col`
- All values in `cells` are unique.

---

## Solution

We use **binary search** to find the last possible day to cross. For each day, we simulate the flooded cells and use **BFS** to check if there is a path from the top to the bottom row.

**Steps:**

1. Use binary search on the number of days.
2. For each day, mark the first `day` cells in `cells` as water.
3. Use BFS from all land cells in the top row to check if any path reaches the bottom row.
4. If crossing is possible, search for a later day; otherwise, search for an earlier day.

**Complexity:**

- **Time:** O(m _ n _ log(m \* n)), where m = row, n = col.
- **Space:** O(m \* n), for visited set.

**Python Code:**

```python
from typing import List
from collections import deque

class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        start = [(1, c) for c in range(1, col + 1)]

        def canCross(day):
            visited = set()
            for i in range(day):
                r, c = cells[i]
                visited.add((r, c))

            q = deque(start)
            while q:
                r, c = q.popleft()
                if not (0 < r <= row and 0 < c <= col) or (r, c) in visited:
                    continue
                if r == row:
                    return True
                visited.add((r, c))
                for nr, nc in ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)):
                    q.append((nr, nc))
            return False

        left, right = 0, len(cells)

        while left < right:
            mid = (left + right + 1) // 2
            if not canCross(mid):
                right = mid - 1
            else:
                left = mid
        return left
```
