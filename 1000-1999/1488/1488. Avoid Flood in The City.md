# 1488. Avoid Flood in The City

## Problem Info

- **Difficulty:** Medium
- **Topics:** Greedy, Array, Hash Table, TreeSet, Heap (Priority Queue)
- [Link to the problem](https://leetcode.com/problems/avoid-flood-in-the-city/)

## Description

You are given an integer array `rains` where:

- `rains[i] > 0` means it rains over the `rains[i]` lake on the `i`th day.
- `rains[i] == 0` means it does not rain on the `i`th day, and you can choose one lake to dry.

Return an array `ans` where:

- `ans.length == rains.length`
- `ans[i] == -1` if `rains[i] > 0`
- `ans[i]` is the lake you choose to dry on the `i`th day if `rains[i] == 0`

If it is impossible to avoid a flood, return an empty array. If there are multiple valid answers, return any of them.

**Notice:** If you dry a full lake, it becomes empty. If you dry an empty lake, nothing changes.

## Examples

### Example 1

- **Input:** `rains = [1,2,3,4]`
- **Output:** `[-1,-1,-1,-1]`
- **Explanation:** Each day it rains on a different lake, and there are no dry days. No floods occur.

### Example 2

- **Input:** `rains = [1,2,0,0,2,1]`
- **Output:** `[-1,-1,2,1,-1,-1]`
- **Explanation:**
  - Day 0: Rain on lake 1 → full lakes: [1]
  - Day 1: Rain on lake 2 → full lakes: [1,2]
  - Day 2: Dry lake 2 → full lakes: [1]
  - Day 3: Dry lake 1 → full lakes: []
  - Day 4: Rain on lake 2 → full lakes: [2]
  - Day 5: Rain on lake 1 → full lakes: [1,2]
  - No floods occur.
  - Other valid answers are possible.

### Example 3

- **Input:** `rains = [1,2,0,1,2]`
- **Output:** `[]`
- **Explanation:**
  - After the second day, lakes [1,2] are full.
  - On the third day, you can dry only one lake, but both lakes will be rained on again, causing a flood.

## Constraints

- `1 <= rains.length <= 10^5`
- `0 <= rains[i] <= 10^9`

---

## Solution

1. **Track full lakes:** Use a hash map to record the last day each lake was filled.
2. **Track dry days:** Use a sorted set (e.g., TreeSet) to keep indices of dry days.
3. **For each rain day:**
   - If the lake is already full, find the earliest dry day after the last rain on this lake and dry it before it rains again.
   - If no such dry day exists, return an empty array (flood is unavoidable).
4. **For each dry day:**
   - If it is not needed to prevent a flood, dry any lake (arbitrary, e.g., lake 1).

**Complexity:**

- **Time:** O(n log n), mainly due to searching for the next dry day.
- **Space:** O(n), for the hash map and set.

**Python Code:**

```python
from typing import List
import bisect

class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        n = len(rains)
        ans = [-1] * n
        lake_last_rain = dict()
        dry_days = []

        for i, lake in enumerate(rains):
            if lake == 0:
                dry_days.append(i)
                ans[i] = 1  # Default, will be updated if needed
            else:
                if lake in lake_last_rain:
                    # Find a dry day after last rain on this lake
                    idx = bisect.bisect_right(dry_days, lake_last_rain[lake])
                    if idx == len(dry_days):
                        return []
                    dry_idx = dry_days[idx]
                    ans[dry_idx] = lake
                    dry_days.pop(idx)
                lake_last_rain[lake] = i
        return ans
```
